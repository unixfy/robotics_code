#pragma config(Motor,  port2,           frontRightMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           backRightMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           frontLeftMotor, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           backLeftMotor, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           skizzorMotorRight, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           skizzorMotorLeft, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           coneGrab,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           mobileGrabber, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                       Competition Template 66233B                         */
/*                                                                           */
/*---------------------------------------------------------------------------*/

/*

-------------------------------------------------------------
I think there is a duck in my router. It always goes NAT, NAT, NAT.
-------------------------------------------------------------
So I want to dress up as a UDP packet for Halloween, but I don't know if anyone will get it.
-------------	------------------------------------------------
I could tell you an ICMP joke but it would probably be repetitive.
-------------------------------------------------------------
I wanted to write an IPv4 joke, but the good ones were all already exhausted.
-------------------------------------------------------------
Linux geek started working at McDonalds.
A customer asked him for a Big Mac and he gave him a bit of paper with FF:FF:FF:FF:FF:FF written on it.
-------------------------------------------------------------
I mount my soul at /dev/null
-------------------------------------------------------------
Why do Python Devs need glasses? Because they don't C#
-------------------------------------------------------------
One does not simply?.. merge into master.
-------------------------------------------------------------
For Windows problems reboot, for Linux problems be root.

*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

void pre_auton()
{
	bStopTasksBetweenModes = true;
}

// ------------------------------------------------------------------------------------------------------------------

task autonomous()
{
	//motor[frontLeftMotor] = -50;
	//motor[frontRightMotor] = -50;
	//motor[backLeftMotor] =  50;
	//motor[backRightMotor] =  50;
	//wait1Msec(500);
	//motor[frontLeftMotor]  = 127;
	//motor[frontRightMotor]  = 127;
	//motor[backLeftMotor] = 127;
	//motor[backRightMotor] = 127;
	//wait1Msec(1500);
	//motor[frontLeftMotor] = 127;
	//motor[frontRightMotor] = 127;
	//motor[backLeftMotor] = -127;
	//motor[backRightMotor] = -127;
	//wait1Msec(500);
	//motor[frontLeftMotor] = 127;
	//motor[frontRightMotor] = 127;
	//motor[backLeftMotor] = 127;
	//motor[backRightMotor] = 127;
	//wait1Msec(1500);

	motor[coneGrab] = 127;
	wait1Msec(550);

	motor[frontLeftMotor] = 127;
	motor[backLeftMotor] = 127;
	motor[frontRightMotor] = 127;
	motor[backRightMotor] = 127;
	wait1Msec(1000);

	motor[skizzorMotorLeft] = 127;
	motor[skizzorMotorRight] = 127;
	wait1Msec(600);

	motor[coneGrab] = -127;
	wait1Msec(550);

	motor[skizzorMotorLeft] = -127;
	motor[skizzorMotorRight] = -127;
	wait1Msec(400);

	motor[frontRightMotor] = 127;
	motor[backRightMotor] = 127;
	motor[frontLeftMotor] = 127;
	motor[backLeftMotor] = 127;

	motor[frontRightMotor] = 127;
	motor[backRightMotor] = 127;

	motor[frontRightMotor] = 127;
	motor[backRightMotor] = 127;
	motor[frontLeftMotor] = 127;
	motor[backLeftMotor] = 127;

	motor[frontRightMotor] = 127;
	motor[backRightMotor] = 127;
	motor[frontLeftMotor] = -127;
	motor[backLeftMotor] = -127;
	wait1Msec(500);

	motor[frontRightMotor] = 127;
	motor[backRightMotor] = 127;

}

task usercontrol()
{
	//motor[frontLeftMotor] = 0;
	//motor[backLeftMotor] = 0;
	//motor[frontRightMotor] = 0;
	//motor[backRightMotor] = 0;
	//while(true){

	//	// Left and right drive motors - hooked up via Y-connector
	//	motor[frontLeftMotor] = vexRT[Ch2];
	//	motor[frontRightMotor] = vexRT[Ch2];
	//	motor[backLeftMotor]  = vexRT[Ch3];
	//	motor[backRightMotor]  = vexRT[Ch3];

	//	// Scissor lift
	//	if(vexRT[Btn6UXmtr2]){
	//		motor[skizzorMotorLeft] = 110;
	//	}
	//	else if(vexRT[Btn6DXmtr2]) {
	//		motor[skizzorMotorLeft] = -110;
	//	}
	//	else {
	//		motor[skizzorMotorLeft] = 0;
	//	}
	//	if(vexRT[Btn6UXmtr2]){
	//		motor[skizzorMotorRight] = 110;
	//	}
	//	else if(vexRT[Btn6DXmtr2]) {
	//		motor[skizzorMotorRight] = -110;
	//	}
	//	else {
	//		motor[skizzorMotorRight] = 0;
	//	}

	//	// Cone lift
	//	if(vexRT[Btn.005UXmtr2]){
	//		motor[coneGrab] = 127;
	//		wait1Msec(550);
	//	}
	//	else if(vexRT[Btn5DXmtr2]) {
	//		motor[coneGrab] = -127;
	//		wait1Msec(550);
	//	}
	//	else {
	//		motor[coneGrab] = 0;
	//	}
	//	}
	motor[frontRightMotor] = 0;
	motor[backRightMotor] = 0;
	motor[frontLeftMotor] = 0;
	motor[backLeftMotor] = 0;

	while(1 == 1)
	{
		// Tank Control
		motor[frontRightMotor] = vexRT[Ch2];
		motor[backRightMotor]  = vexRT[Ch2];
		motor[frontLeftMotor] = vexRT[Ch3];
		motor[backLeftMotor]  = vexRT[Ch3];

		// Scissor Lift
		if(vexRT[Btn6UXmtr2]){
			motor[skizzorMotorLeft] = 110;
			motor[skizzorMotorRight] = 110;
		}
		else if(vexRT[Btn6DXmtr2]) {
			motor[skizzorMotorLeft] = -110;
			motor[skizzorMotorRight] = -110;
		}
		else {
			motor[skizzorMotorLeft] = 0;
			motor[skizzorMotorRight] = 0;
		}

		// Cone Lift
		if(vexRT[Btn5UXmtr2]){
			motor[coneGrab] = 127;
			wait1Msec(550);
		}
		else if(vexRT[Btn5DXmtr2]) {
			motor[coneGrab] = -127;
			wait1Msec(550);
		}
		else {
			motor[coneGrab] = 0;
		}

		// Mobile Cone
		if(vexRT[Btn8U]){
			motor[mobileGrabber] = 	70;
		}
		else if(vexRT[Btn8D]){
			motor[mobileGrabber] = -70;
		}
		else {
			motor[mobileGrabber] = 0;
		}

	}
}
